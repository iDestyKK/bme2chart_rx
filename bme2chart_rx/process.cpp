#include "process.h"
#include "bme.h"

using namespace std;

void generate_INI(string path, vector<string> &charts, vector<BME> &BME表, vector<BPM> &AdvBPM, vector<BPM> &BPM表, const string &out_path, string &chart_header) {
	int first = -1;

	string line, prtln, bfln, afln, attln, bycol;
	string sname = "", sartist = "", sgenre = "";
	unsigned int bpmf = 0;

	//今、ChartのInfoを受けます。
	for (int i = 0; i < charts.size(); i++) {
		if (charts[i] == "")
			continue;

		first = i;
		ifstream fp(charts[i]);

		while (getline(fp,line)) {
			if (line.length() == 0)
				continue;
			if (line[0] == '#') {
				//EVENT!
				prtln = line.substr(1, 3);
				attln = line.substr(4, 2);
				bycol = line.substr(7, line.length() - 7);
				bfln  = line.substr(1, line.find(' ') - 1);
				afln  = line.substr(line.find(' ') + 1, line.length() - (line.find(' ') + 1));
				if (prtln == "WAV") {
					//BME表[i].soundfont加える(AUDIO(attln, bycol));
				}
				else if (prtln == "BMP") {
					//聞き流す。
				}
				else if (bfln == "BPM") {
					bpmf = ToReal(afln);
					BPM表.push_back(BPM(0, bpmf * 1000));
				}
				else if (prtln == "BPM")
					AdvBPM.push_back(BPM(attln, ToReal(bycol)));
				else if (bfln == "TITLE")
					sname = afln;
				else if (bfln == "ARTIST")
					sartist = afln;
				else if (bfln == "GENRE")
					sgenre = afln;
				else if (bfln == "PLAYLEVEL" || bfln == "PLAYER") {
					//しません。
				} else {
					//なし。。。
				}
			}
		}

		fp.close();
		break;
	}

	if (first == -1) {
		cerr << "Error Reading Charts (Error -02)" << endl;
		exit(0);
	} else {
		//KBH_INFO.iniを書きます。
		cout << "Writing KBH_INFO.ini" << endl;
		ofstream op("KBH_INFO.ini");
		
		op << "//BME Chart for Project RX" << endl;
		op << "//Generated by bme2chart_rx" << endl << endl;
		op << "[DATA]\n{\n\tdlc_type\t= IIDX CHART\n\tmin_version\t= 1\n\tDTA_version\t= 0\n}\n" << endl;
		op << "[SONGDATA]\n{\n\tname\t= " << sname << "\n\tartist\t= " << sartist << "\n\tyear\t= ??\n\tgenre\t= " << sgenre << "\n\tyear\t= ??\n\talbum\t= ??\n\tlength\t= ??\n\tBPM\t= " << bpmf << "\n}\n" << endl;
		op << "[TRACKDATA]\n{\n\tnumber_of_tracks\t= 0\n\tpreview\t= preview.ogg\n\tchart\t= " << out_path << "\n}\n" << endl;
		op << "[DIFFICULTIES]\n{\n\tbm_beginner\t= 0\n\tbm_normal\t= 0\n\tbm_hyper \t= 0\n\tbm_another\t= 0\n}\n" << endl;

		op.close();
	}

	chart_header = "[Song]\n{\n\tName = " + sname + "\n\tArtist = " + sartist + "\n\tCharter = bme2chart_rx\n\tOffset = 0\n\tResolution = 960\n\tPlayer2 = Bass\n\tDifficulty = 0\n\tPreviewStart = 0.00\n\tPreviewEnd = 0.00\n\tGenre = " + sgenre + "\n\tMediaType = \"cd\"\n\tMusicStream = \"song.ogg\"\n}";
}

void generate_keysounds(vector<string> &charts, vector<BME> &BME表, vector<BPM> &AdvBPM, const string &out_path) {
	string line, prtln, attln, bycol;
	string sname = "", sartist = "", sgenre = "";
	unsigned int bpmf = 0;

	//今、ChartのKeysoundsを受けます。
	for (int i = 0; i < charts.size(); i++) {
		if (charts[i] == "")
			continue;

		ifstream fp(charts[i]);

		while (getline(fp,line)) {
			if (line.length() == 0)
				continue;
			if (line[0] == '#') {
				//EVENT!
				prtln = line.substr(1, 3);
				attln = line.substr(4, 2);
				bycol = line.substr(7, line.length() - 7);
				if (prtln == "WAV") {
					BME表[i].soundfont加える(AUDIO(attln, bycol));
				}
			}
		}

		fp.close();
	}
}

void generate_BPM(vector<string> &charts, vector<BME> &BME表, vector<BPM> &AdvBPM, vector<BPM> &BPM表, vector<STRETCHER> &STRETCHER表, const string &out_path) {
	string line, prtln, attln, bycol;
	string sname = "", sartist = "", sgenre = "";
	unsigned int bpmf = 0;

	//今、ChartのKeysoundsを受けます。
	for (int i = 0; i < charts.size(); i++) {
		if (charts[i] == "")
			continue;

		//BMEのファイルを開けて読みます。
		ifstream fp(charts[i]);
		if (fp.fail()) {
			cerr << "File Failed to be opened" << endl;
		}
		string line, prtln, bfln, afln, attln, bycol, events;
		int measure, attribute, ev_size, line_number;
		line_number = 0;

		while (getline(fp,line)) {
			line_number++;

			if (line.length() == 0)
				continue;

			if (line[0] == '#') {
				//EVENT!
				prtln = line.substr(1, 3);
				attln = line.substr(4, 2);
				bycol = line.substr(7, line.length() - 7);
				bfln  = line.substr(1, line.find(' ') - 1);
				afln  = line.substr(line.find(' ') + 1, line.length() - (line.find(' ') + 1));

				if (prtln == "WAV" || prtln == "BMP" || bfln == "BPM" || prtln == "BPM" || bfln == "RANK" || bfln == "TOTAL" || bfln == "STAGEFILE" || bfln == "TITLE"|| bfln == "ARTIST" || bfln == "GENRE" || bfln == "PLAYLEVEL" || bfln == "DIFFICULTY" || bfln == "PLAYER") {
					//しません。
				} else {
					measure   = ToReal(prtln);
					attribute = ToReal(attln);
					events = bycol;
					ev_size = events.length() / 2;
					if (attribute == 2) {
						int event_num = events.length() / 2;
						string ev_str;

						for (int i = 0; i < event_num; i++) {
							ev_str = events.substr(i * 2, 2);
							if (ev_str != "00") {
								STRETCHER表.push_back(STRETCHER(measure, ToDouble(bycol)));
							}
						}
					}

					if (attribute == 3) {
						int event_num = events.length() / 2;
						string ev_str;

						for (int i = 0; i < event_num; i++) {
							ev_str = events.substr(i * 2, 2);
							if (ev_str != "00") {
								BPM表.push_back(BPM((measure * (960 * 4)) + ((960 * 4) * ((double)i / event_num)), HexToInt(ev_str) * 1000));
							}
						}
					}
					
					if (attribute == 8) {
						int event_num = events.length() / 2;
						string ev_str;

						for (int i = 0; i < event_num; i++) {
							ev_str = events.substr(i * 2, 2);
							if (ev_str != "00") {
								for (int a = 0; a < AdvBPM.size(); a++) {
									if (ev_str == AdvBPM[a].attr) {
										BPM表.push_back(BPM((measure * (960 * 4)) + ((960 * 4) * ((double)i / event_num)), AdvBPM[a].bpm * 1000));
									}
								}
							}
						}
					}
				}
			}
		}

		fp.close();
		break;
	}
}